
namespace ProbabilisticZ3

open System
open System.Diagnostics

open PrismModel
open Utils
open Expressions
open Microsoft.Z3
open SolverConfigs
open Problems
open Paths
open EncodingContext
open CounterExamples
open ExpressionEncodings
open PrismModelEncoding
open GuardEncoding
open AnalyzerContexts
open Statistics

// Contains recurring structures for encoding individual checks inside 
// an abstraction and that are used accross different tactics. 
module AnalyzerContextEncodings = 
    
    let relevantRandomVars (ac:AnalyzerContext) : Expr list list = take (ac.CurrentStepBound) ac.co.randomVars
    let relevantRandomVarsSorts (ac:AnalyzerContext) : Sort list list = take (ac.CurrentStepBound) ac.co.randomVarsSorts
    let relevantSysStateVars (ac:AnalyzerContext) : Expr list list = take (ac.CurrentStepBound+1) ac.co.sysStateVars
    let relevantSysStateVarsSorts (ac:AnalyzerContext) : Sort list list = take (ac.CurrentStepBound+1) ac.co.sysStateVarsSort

    // Excludes deadlocked states in the reachable part but allows the final states (after CurrentStepBound steps) to be deadlocks
    let noDeadlock (co:EncodingContext) (curStepBound:int) : BoolExpr = 
        let stepConstraints : BoolExpr list = 
            match co.problem.configs.SimplifiedGuardEncoding with
            | true -> 
                List.mapi // replaces List.zip [0..ac.CurrentStepBound-1]  
                    (fun (step:int) (sysState:Expr list) -> 
                        if step=curStepBound then co.z3.MkTrue() else
                        let stepExpr : Expr = upcast co.z3.MkBV(step,co.stepBVSize)                        
                        co.z3.MkNot(co.z3.MkBoolConst("var_auxiliarySyncLabel_xkRbUclPoc3mSAShTH5L_" + step.ToString())) // HACK! The variable name should actually be generated by a function like "variable2Z3Const_step"
                        )
                << take curStepBound // We do explicitely not exclude deadlocks in the last step 
                <| co.sysStateVars 
            | false -> 
                List.mapi
                    (fun (step:int) (sysState:Expr list) -> 
                        if step=curStepBound then co.z3.MkTrue() else
                        let stepExpr : Expr = upcast co.z3.MkBV(step,co.stepBVSize)
                        let strategyArgs = 
                            match co.problem.configs.StrategyEncoding with
                            | Memoryless ->         Array.ofList <| sysState
                            | StateTimeDependent -> Array.ofList <| stepExpr :: sysState
                        co.z3.MkNot(co.z3.MkEq(
                                      downcast co.z3.MkApp(co.strategy, strategyArgs),
                                      co.z3.MkBV(co.syncLabelsNumbersMap.Item("auxiliarySyncLabel_xkRbUclPoc3mSAShTH5L"),co.synchNameChoiceBVSize)))) 
                << take curStepBound
                <| co.sysStateVars 
                    // we allow the last state to be a deadlock ... no action must be chosen here ... but lists for List.zip need to be of same length; last step excluded via if-statement above

        co.z3.MkAnd(Array.ofList stepConstraints)



    let variableRangesAllSteps (co:EncodingContext) (curStepBound:int) : BoolExpr = 
        z3mkAnd co.z3 
        << List.collect 
                (fun (step:int, vars:Expr list) -> 
                    if step<=curStepBound
                    then downcast co.z3.MkApp(co.variableRangeFunction, Array.ofList vars)::[]
                    else [])
        << List.zip [0..curStepBound] 
        << take (curStepBound+1)
        <| co.sysStateVars
    


    let allStepsTransitionRelation (co:EncodingContext) (curStepBound:int) : BoolExpr = 
        z3mkAnd co.z3 
        << List.mapi
            (fun (step:int) 
                  (randomVars:Expr list, 
                   (sysStateVars:Expr list, nextSysStateVars:Expr list, 
                    (formulaVars:Expr list, 
                     (syncGuardVars:Expr list,pChoiceVars)))) -> 
                let currentStep : Expr = // if co.prismModel.Type.Equals(DTMC) then co.z3.MkBV(0,co.stepBVSize) :> Expr else 
                    co.z3.MkBV(step,co.stepBVSize) :> Expr
                downcast co.z3.MkApp(
                    co.transitionRelation,
                    Array.ofList ( currentStep :: randomVars @ sysStateVars @ nextSysStateVars @ formulaVars @ syncGuardVars @ pChoiceVars)))
        // << List.zip [0..curStepBound-1] // replaced by use of List.mapi
        << List.zip (take curStepBound co.randomVars)
        << List.zip3 (take curStepBound co.sysStateVars) (take curStepBound co.sysStateVars.Tail)
        << List.zip (take curStepBound co.formulaVars)
        << List.zip (take curStepBound co.syncGuardVars)
        << take curStepBound
        <| co.pChoiceVars

        
    let allStepsFormulaConstraints (co:EncodingContext) (steps:int): BoolExpr = 
//        let formulaConstraints : BoolExpr = 
//            downcast co.z3.MkApp(co.formulaDefinitions,Array.ofList (co.sysStateArgs @ co.formulaArgs))
        z3mkAnd co.z3
        << List.map
            (fun (sysStateVars:Expr list, formulaVars:Expr list) -> 
                downcast co.z3.MkApp(co.formulaDefinitions,Array.ofList (sysStateVars @ formulaVars)))
        << take (steps+1)
        << List.zip co.sysStateVars
        <| co.formulaVars



    let finalCondition (co:EncodingContext) (thereAtStep:int option) : BoolExpr = // create the final condition
        match co.problem.GoalRegion with
        | Positive s | Negative s -> 
            let labelOption = 
                List.tryFind
                    (fun (label,labelExpr:Expressions.BoolExpr) -> label.Equals(s))
                    co.prismModel.Labels
            let goalRegionExpr = 
                match labelOption with
                | Some (label,labelExpr) -> translateBoolExpr co thereAtStep None labelExpr 
                | None -> invalidArg "label" ("The specified label was not found in the prism file.")
            match co.problem.GoalRegion with
            | Positive s -> goalRegionExpr
            | Negative s -> co.z3.MkNot goalRegionExpr
            | _ -> raise (InnerError "Cannot happen.")
        | Empty -> co.z3.MkTrue()


    let modelDefinitions (co:EncodingContext) (abstr:AbstractionType) : BoolExpr = 
        co.z3.MkAnd
            [|
            encodeTransitionRelation co abstr ;
            encodeVariableRanges co ;
            encodeFormulaDefinitions co ;
            (if co.problem.configs.SimplifiedGuardEncoding 
                then encodeGuardsNewEncoding co
                else encodeGuards co) ; 
            |]

    let assembleBMCFormula (co:EncodingContext) (pre:PrecomputedZ3Objects) (negateGoalRegion:bool) (steps:int)  (abstr:AbstractionType) : BoolExpr =

        let p = co.z3.MkParams()
//        p.Add("local-ctx",true)
//        parameters.Add("blast-eq-value",true)
//        p.Add("cache-all",true)
//        p.Add("elim-and",true)
//        p.Add("push-ite-bv",true)
        let tr = allStepsTransitionRelation co steps
        let formulas = allStepsFormulaConstraints co steps
        let dl = noDeadlock co steps
        let ranges = variableRangesAllSteps co steps
        let fin = 
            (if negateGoalRegion 
            then co.z3.MkNot 
            else id) <| finalCondition (co:EncodingContext) (Some steps)
        let result = 
            co.z3.MkAnd
                [|
                (if abstr.Equals UNDERAPPROX  then pre.TRDef_underApprox else pre.TRDef_overApprox) ;
                pre.VariableRangeDefs ;
                pre.FormulaDefs; // not simplifying, as this sometimes causes the definition to be purged and it is subsequently not picked up by the macro-finder. 
                downcast pre.GuardDefs.Simplify(p) ;
                downcast tr.Simplify(p) ;
                downcast formulas.Simplify(p) ;
                downcast ranges.Simplify(p) ;
                downcast fin.Simplify(p) ; 
                pre.InitialCondition ;
                downcast dl.Simplify(p) ; 
                |]
        result

//    let applyTactic (co:EncodingContext) (tactic:Tactic) (bmcFormula : BoolExpr) : BoolExpr = 
    let applyTactic (ac:AnalyzerContext) (tactic:Tactic) (expr : BoolExpr) : BoolExpr = 
        let g : Goal = ac.co.z3.MkGoal(true,false,false)
        g.Assert(expr)
        let ar : ApplyResult = tactic.Apply(g)
        let ar2 = Array.collect (fun (g:Goal) -> g.Formulas) ar.Subgoals
        let it = ac.co.z3.MkAnd ar2
        it

    let customSimplify (ac:AnalyzerContext) (bmcFormula : BoolExpr) : BoolExpr = 
        let co = ac.co
        let t_macro_finder = co.z3.MkTactic("macro-finder")
        let t_ctx_simplify = co.z3.MkTactic("ctx-simplify")
        let it0 = applyTactic ac t_macro_finder bmcFormula
        let it1 : BoolExpr = downcast it0.Simplify()
        let it2 = applyTactic ac t_ctx_simplify it1
//        let it2 = applyTactic co t_ctx_simplify it1
        it2

    let bakeBMCFormulas ac : AnalyzerContext =
        if ac.co.problem.configs.CTXSimplifierBaking
        then 
            let stopWatch = Stopwatch.StartNew()
            ac.bmcFormula_underApprox <- customSimplify ac ac.bmcFormula_underApprox
            ac.bmcFormula_overApprox_negatedGoal <- customSimplify ac ac.bmcFormula_overApprox_negatedGoal
            stopWatch.Stop()
            ac.Statistics.SimplifyTime <- ac.Statistics.SimplifyTime+stopWatch.Elapsed.TotalSeconds
        ac

    let updateBMCFormulas ac : AnalyzerContext = 
        ac.bmcFormula_underApprox <- assembleBMCFormula ac.co ac.PrecomputedZ3Objects false ac.CurrentStepBound UNDERAPPROX
        ac.bmcFormula_overApprox_negatedGoal <- assembleBMCFormula ac.co ac.PrecomputedZ3Objects true ac.CurrentStepBound OVERAPPROX
        ac

    let initializePrecomputedZ3Objects (co:EncodingContext) : PrecomputedZ3Objects =
        let trDef_UnderApprox = encodeTransitionRelation co UNDERAPPROX
        let trDef_OverApprox = encodeTransitionRelation co OVERAPPROX
        let rangeDef = encodeVariableRanges co 
        let formulaDef = encodeFormulaDefinitions co 
        let guardDef = 
            if co.problem.configs.SimplifiedGuardEncoding 
                    then encodeGuardsNewEncoding co
                    else encodeGuards co
        
        
        let init = initialCondition co
        let p = co.z3.MkParams()
//        p.Add("local-ctx",true)
//        parameters.Add("blast-eq-value",true)
//        p.Add("cache-all",true)
//        p.Add("elim-and",true)
//        p.Add("push-ite-bv",true)
        {
        InitialCondition = downcast init.Simplify(p) ;
        TRDef_underApprox = downcast trDef_UnderApprox.Simplify(p) ;
        TRDef_overApprox = downcast trDef_OverApprox.Simplify(p) ;
        VariableRangeDefs = downcast rangeDef.Simplify(p)
        FormulaDefs = formulaDef
        GuardDefs = downcast guardDef.Simplify(p)
        }

    let initialAC co : AnalyzerContext  = 
        let preComp = initializePrecomputedZ3Objects co
        {
        AbstractionName = None ;
        ExpectedResult = None ;
        co = co ;
        PrecomputedZ3Objects = preComp ; 
        bmcFormula_underApprox = assembleBMCFormula co preComp false 1 UNDERAPPROX ; 
        bmcFormula_overApprox_negatedGoal = assembleBMCFormula co preComp true 1 OVERAPPROX ; 
        CurrentStepBound = 1 ;
        GoalRegion = Empty ;
        PositiveCubes = [] ;
        AccumulatedProbability = 0.0 ;
        BitRelevancy = 1 ;
        NoPathToGoalRegionUntilStep = None ;
        LargestCubeSizeFound = Int32.MaxValue / 2 ;
        CubeSizeSpread = 0 ;
        MaximalCubeSize = 1 ;
        CubeSizeIncrement = 4 ; 
        IrrelevantBits = Set.empty ;
        RelevantBits = Set.empty ;
//        SolverCache = {PathSolver = None ; CCESolver = None ; CubeCandidateSolver = None}
        CECache = []
        Statistics = freshStatisticsObject
    }




